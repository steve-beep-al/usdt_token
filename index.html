<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Claim 5 Demo Coins — Debug Version</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 18px; }
    button { padding: 8px 12px; margin-right: 8px; }
    #status { margin-top: 12px; font-weight: bold; }
    #log { margin-top: 12px; white-space: pre-wrap; background:#f7f7f7; padding:8px; border:1px solid #ddd; height:220px; overflow:auto; }
  </style>
</head>
<body>
  <h1>Claim 5 Demo Coins — Debug</h1>
  <button id="connectBtn">Connect Wallet</button>
  <button id="claimBtn" disabled>Claim Now (mint 5)</button>

  <div id="status">Status: waiting</div>
  <div id="balances">
    
  </div>
  <div id="log"></div>

  <!-- MetaMask SDK (fallback for mobile) -->
  <script src="https://cdn.jsdelivr.net/npm/@metamask/sdk@0.17.1/dist/browser/iife/index.min.js"></script>
  <!-- ethers -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>

  <script>
  /************** CONFIG — REPLACE THESE VALUES **************/
  const tokenAddress = "0x0D8C190055e5BdC488D00086CFdfE45A7704C28C"; // your token contract
  const tokenSymbol  = "USDT";     // symbol shown in UI
  const tokenDecimals= 6;          // token decimals
  const tokenImage   = "https://png.pngtree.com/png-vector/20220513/ourmid/pngtree-tetherusdtvector-illustration-of-a-wellknown-altcoin-cryptocurrency-icon-vector-png-image_36462248.png";
  const mintAmount   = ethers ? ethers.utils.parseUnits("5", tokenDecimals) : null; // 5 tokens
  const tokenPrice   = 1; // $1 (demo)
  // optional: set required chainId hex (if you want to enforce a network)
  const requiredChainIdHex = null; // example: '0x5' for Goerli; set to null to accept current network
  /**********************************************************/

  const logEl = document.getElementById('log');
  const statusEl = document.getElementById('status');
  function log(...args){
    const text = args.map(a => (typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a))).join(' ');
    console.log(...args);
    logEl.innerText += text + '\n';
    logEl.scrollTop = logEl.scrollHeight;
  }
  function setStatus(msg){
    statusEl.innerText = 'Status: ' + msg;
    log('STATUS:', msg);
  }

  // minimal ABI for actions we need
  const tokenAbi = [
    "function mint(address to, uint256 amount) public",
    "function balanceOf(address owner) view returns (uint256)",
    "function owner() view returns (address)", // optional
    "event Transfer(address indexed from, address indexed to, uint256 value)"
  ];

  // globals
  let ethereum = null;
  let provider = null;
  let signer = null;
  let userAddress = null;
  let tokenContractProvider = null; // read-only
  let tokenContractSigner = null;   // write

  // Initialize provider: prefer injected window.ethereum, fallback to MetaMask SDK provider
  function initProvider(){
    if (window.ethereum){
      ethereum = window.ethereum;
      provider = new ethers.providers.Web3Provider(ethereum);
      log('Using injected window.ethereum provider');
      return true;
    }
    if (window.MetaMaskSDK && window.MetaMaskSDK.MetaMaskSDK){
      try {
        const MMSDK = new window.MetaMaskSDK.MetaMaskSDK({
          dappMetadata: { name: 'Demo Dapp', url: window.location.href },
          // infuraAPIKey optional here if you want the SDK to create a provider
        });
        ethereum = MMSDK.getProvider();
        provider = new ethers.providers.Web3Provider(ethereum);
        log('Using MetaMask SDK provider');
        return true;
      } catch (e){
        log('MetaMask SDK init failed:', e);
      }
    }
    log('No provider available (install MetaMask or use MetaMask mobile).');
    return false;
  }

  // Connect wallet & prepare contracts
  async function connectWallet(){
    try {
      setStatus('Initializing provider...');
      if (!initProvider()) {
        setStatus('No wallet provider found.');
        return;
      }

      setStatus('Requesting account access (connect)...');
      // request accounts (this will trigger wallet connect popup)
      await ethereum.request({ method: 'eth_requestAccounts' });
      signer = provider.getSigner();
      userAddress = await signer.getAddress();
      log('Connected address:', userAddress);
      setStatus('Connected: ' + userAddress.slice(0,8) + '...');

      // check chain if required
      if (requiredChainIdHex){
        const chainId = await provider.send('eth_chainId', []);
        log('Current chainId:', chainId);
        if (chainId !== requiredChainIdHex){
          setStatus('Wrong network (expected ' + requiredChainIdHex + '). Please switch network in wallet.');
          // you may add wallet_addEthereumChain here if you want
        }
      }

      // attach contracts: provider for read, signer for write
      tokenContractProvider = new ethers.Contract(tokenAddress, tokenAbi, provider);
      tokenContractSigner   = new ethers.Contract(tokenAddress, tokenAbi, signer);

      // show token symbol
      document.getElementById('sym').innerText = tokenSymbol;

      // enable claim button
      document.getElementById('claimBtn').disabled = false;

      // initial balance fetch
      await updateBalance();

      // listen Transfer events (read-only provider)
      tokenContractProvider.on('Transfer', async (from, to, value) => {
        log('Transfer event:', {from, to, value: value.toString()});
        if (!userAddress) return;
        if (from.toLowerCase() === userAddress.toLowerCase() || to.toLowerCase() === userAddress.toLowerCase()){
          await updateBalance();
        }
      });

      log('Connected and listening for Transfer events.');
    } catch (err){
      console.error(err);
      setStatus('Connect failed');
      log('Connect error:', err);
      alert('Connect failed: ' + (err.message || err));
    }
  }

  // Add token to wallet UI (metadata)
  async function addTokenToWallet(){
    if (!ethereum || !ethereum.request) return false;
    try {
      const wasAdded = await ethereum.request({
        method: 'wallet_watchAsset',
        params: {
          type: 'ERC20',
          options: {
            address: tokenAddress,
            symbol: tokenSymbol,
            decimals: tokenDecimals,
            image: tokenImage
          },
        },
      });
      log('wallet_watchAsset result:', wasAdded);
      return wasAdded;
    } catch (e){
      log('wallet_watchAsset error:', e);
      return false;
    }
  }

  // Claim (mint) tokens
  async function claimDemoCoins(){
    try {
      if (!tokenContractSigner || !signer) {
        alert('Not connected. Please connect wallet first.');
        return;
      }

      setStatus('Requesting to add token to wallet UI (optional)...');
      await addTokenToWallet();

      setStatus('Sending mint transaction — confirm in wallet...');
      // attempt to call mint()
      const tx = await tokenContractSigner.mint(userAddress, mintAmount);
      log('mint tx hash:', tx.hash);
      setStatus('Mint tx sent, waiting confirmation...');
      await tx.wait();
      setStatus('Mint confirmed!');
      log('Mint confirmed.');

      await updateBalance();
      alert('✅ Minted ' + ethers.utils.formatUnits(mintAmount, tokenDecimals) + ' ' + tokenSymbol);
    } catch (err) {
      console.error('Mint failed:', err);
      setStatus('Mint failed: ' + (err.message || err));
      log('Mint error details:', err);
      // common reason: mint is owner-only and your wallet is not owner
      if (err && err.message && err.message.toLowerCase().includes('revert')){
        alert('mint() reverted. Likely the connected account is not contract owner or mint is restricted.');
      } else {
        alert('Mint failed: ' + (err.message || err));
      }
    }
  }

  // Read & display balance
  async function updateBalance(){
    try {
      if (!tokenContractProvider || !userAddress) return;
      const raw = await tokenContractProvider.balanceOf(userAddress);
      const human = Number(ethers.utils.formatUnits(raw, tokenDecimals));
      document.getElementById('balance').innerText = human;
      document.getElementById('value').innerText = (human * tokenPrice).toFixed(2);
      setStatus('Balance updated: ' + human + ' ' + tokenSymbol);
      log('Balance read:', raw.toString(), '=>', human);
    } catch (e){
      log('Failed to fetch balance:', e);
    }
  }

  // wire buttons
  document.getElementById('connectBtn').addEventListener('click', connectWallet);
  document.getElementById('claimBtn').addEventListener('click', claimDemoCoins);

  // initial
  setStatus('Ready — click Connect Wallet');
  log('Page loaded. Ensure you open this page via http:// (not file://).');

  </script>
</body>
</html>
